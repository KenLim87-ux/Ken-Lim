import React, { useEffect, useMemo, useRef, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { ResponsiveContainer, RadarChart, PolarGrid, PolarAngleAxis, Radar } from "recharts";
import { Slider } from "@/components/ui/slider";
import { Button } from "@/components/ui/button";

// ========================= è¦ç‚¹ï¼ˆæœ¬æ¬¡å‡çº§ï¼‰ =========================
// âœ… é»‘ç®±å¯è§†åŒ–é¢æ¿ï¼ˆç¦»çº¿å¯è·‘ï¼‰ï¼š
//    1) å¤šæ¬¡ç”Ÿæˆç¼å¸¦ï¼ˆp10~p90 åŒºé—´ï¼‰ 2) è¯/å¥é‡è¦åº¦çƒ­å›¾ï¼ˆé®è”½æ³•ï¼‰
//    3) (KÃ—C) çƒ­åŠ›å›¾ï¼ˆå›ºå®š Lï¼‰ 4) äº‹ä»¶æ—¶é—´çº¿ï¼ˆå« Barrier/Gate æ³¨é‡Šï¼‰
// âœ… ä¿®å¤ï¼šmapKLCToApi çš„å…œåº•é”®åæ‹¼å†™é”™è¯¯ï¼ˆcreativeï¼‰ï¼ŒsimulateTextOffline éšæœºæ•°ç»Ÿä¸€èµ°ç§å­ PRNG
// âœ… ä¿ç•™ï¼šAPI å¼€å…³ã€Jump/Weave/Gate å®ã€å¾®æ‰«æã€æŒ‡æ ‡ D/S/Rã€ç¦»çº¿æ¨¡æ‹Ÿã€è‡ªæµ‹
// ==================================================================

// â€”â€” å·¥å…·ï¼šæ¸…ç†ä¸å¯è§å­—ç¬¦ â€”â€”
function sanitizeText(str) {
  if (typeof str !== "string") return str;
  return str.replace(/[\u00A0\u200B\u200C\u200D\uFEFF]/g, " ");
}

// â€”â€” Profile è®¾å®š â€”â€”
const PROFILES = {
  creative: { label: "Creative", tMin: 0.5, tMax: 1.0, pMin: 0.7, pMax: 1.0, minTokens: 512, maxTokens: 1792 },
  factual:  { label: "Factual",  tMin: 0.2, tMax: 0.6, pMin: 0.5, pMax: 0.9,  minTokens: 512, maxTokens: 1536 },
  code:     { label: "Code",     tMin: 0.15,tMax: 0.5, pMin: 0.5, pMax: 0.85, minTokens: 256, maxTokens: 1536 },
};

// â€”â€” çº¯å‡½æ•°ï¼šå½’ä¸€åŒ– & æ˜ å°„ â€”â€”
function normalizeKLC(obj) {
  const s = Math.max(1e-9, (obj.K || 0) + (obj.L || 0) + (obj.C || 0));
  return { K: (obj.K || 0) / s, L: (obj.L || 0) / s, C: (obj.C || 0) / s };
}
function mapKLCToApi(klc, profileKey = "creative") {
  const P = PROFILES[profileKey] || PROFILES.creative;
  const temperature = P.tMin + (P.tMax - P.tMin) * Math.min(1, Math.max(0, klc.K));
  const top_p = P.pMax - (P.pMax - P.pMin) * Math.min(1, Math.max(0, klc.C));
  const max_tokens = Math.round(P.minTokens + (P.maxTokens - P.minTokens) * Math.min(1, Math.max(0, klc.L)));
  return { temperature: +temperature.toFixed(2), top_p: +top_p.toFixed(2), max_tokens };
}

// â€”â€” å­˜å‚¨é”® â€”â€”
const STORE_KEY = "cockpit:v3.2";

// â€”â€” ä¼ªéšæœºï¼ˆç¦»çº¿æ¨¡æ‹Ÿå¯é‡å¤ï¼‰ â€”â€”
function strHash(s) { let h = 2166136261 >>> 0; for (let i = 0; i < s.length; i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); } return h >>> 0; }
function makePRNG(seed) { let a = (seed || 1) >>> 0; return () => { a = (a * 1664525 + 1013904223) >>> 0; return a / 2 ** 32; }; }

// â€”â€” ç¦»çº¿æ¨¡æ‹Ÿå™¨ï¼šä¾æ® K/L/C æ‹¼è£…æ–‡æœ¬ï¼ˆç»Ÿä¸€ç§å­éšæœºï¼‰ â€”â€”
function simulateTextOffline(prompt, klc, profileLabel, seedBump = 0) {
  const p = sanitizeText((prompt || "").trim());
  const seed = strHash(p + JSON.stringify(klc) + (profileLabel || "") + ":" + String(seedBump));
  const rnd = makePRNG(seed);
  const adj = ["å¤§èƒ†", "çµæ´»", "å¤šæ ·", "å‰ç»", "å¼‚æƒ³å¤©å¼€", "è·¨åŸŸ", "ç‹¬åˆ°", "å¯Œæœ‰å¼ åŠ›"];
  const verbs = ["é‡æ„", "äº¤ç»‡", "è¿­ä»£", "æ¶Œç°", "åˆ†è§£", "èšåˆ", "å¯¹é½", "è½åœ°"];
  const caveats = ["æˆ–è®¸", "å¯èƒ½", "å‡è®¾", "ä¸å¦¨", "å€¼å¾—å°è¯•", "å¯å‘æ€§åœ°" ];
  const headers = ["æ¡†æ¶", "è·¯å¾„", "æ–¹æ¡ˆ", "èŠ‚æ‹", "èŒƒå¼", "è“å›¾", "è·ƒè¿", "æ ¸å¯¹æ¸…å•"]; 
  const K = klc.K, L = klc.L, C = klc.C;
  const sec = Math.max(2, Math.min(8, Math.round(2 + 6 * L)));
  const bulletsPer = Math.max(2, Math.min(5, Math.round(1 + 4 * L)));
  const hedgy = C < 0.2 ? caveats : ["å»ºè®®", "æ˜ç¡®", "åº”å½“"];
  const pick = (arr) => arr[Math.floor(rnd() * arr.length)];
  const lines = [];
  const title = p ? `ã€æ¨¡æ‹Ÿã€‘${p}` : "ã€æ¨¡æ‹Ÿã€‘ç¤ºä¾‹è¾“å‡º";
  lines.push(title, "", `Profile: ${profileLabel} | K=${K.toFixed(2)} L=${L.toFixed(2)} C=${C.toFixed(2)}`, "");
  if (K > 0.55) { lines.push(`${pick(hedgy)}ä»ä¸€ä¸ªå¤§èƒ†è®¾æƒ³å¼€å§‹ï¼šå¦‚æœæˆ‘ä»¬ä»¥â€œ${pick(adj)}â€çš„æ–¹å¼å»${pick(verbs)}è¿™ä¸ªé—®é¢˜ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ`, ""); }
  for (let i = 1; i <= sec; i++) {
    const h = pick(headers);
    lines.push(`${i}. ${h}ï¼ˆ${pick(adj)} x ${pick(verbs)}ï¼‰`);
    for (let j = 0; j < bulletsPer; j++) {
      const flavor = K > 0.6 && rnd() > C ? pick(adj) : "";
      const verb = pick(verbs);
      lines.push(`   - ${(C<0.2?pick(caveats):"å»ºè®®")}ä»¥${flavor?flavor+"çš„":""}${verb}æ–¹å¼å±•å¼€ç¬¬${i}èŠ‚è¦ç‚¹ï¼Œå¹¶ç»™å‡ºå¯æ“ä½œçš„ä¸‹ä¸€æ­¥ã€‚`);
    }
    lines.push("");
  }
  if (C < 0.2) { lines.push("æ¢ç´¢è¾¹ç•Œï¼š", "- å…è®¸å°‘é‡è·³å‡ºå¼è”æƒ³ï¼Œä½†ä¿æŒä¸ä¸»çº¿å¯¹é½ã€‚", "- ç”¨ç¤ºä¾‹/å¯¹æ¯”å¿«é€ŸéªŒè¯ï¼Œé”™ä¹Ÿè¦å¿«é”™å¿«æ”¹ï¼ˆå¾®æ‰°æ”¶æ•›ï¼‰ã€‚"); }
  else { lines.push("æ”¶æ•›æç¤ºï¼š", "- æ˜ç¡®éªŒæ”¶æ ‡å‡†ä¸çº¦æŸæ¡ä»¶ï¼Œç¡®ä¿ä¸€è‡´æ€§ä¸å¯å¤ç°ã€‚"); }
  return lines.join("\n");
}

// â€”â€” æ–‡æœ¬æŒ‡æ ‡ï¼šD/S/Rï¼ˆ0..1 è¿‘ä¼¼ï¼‰ â€”â€”
function computeMetrics(text) {
  const t = sanitizeText(text || "").trim();
  if (!t) return { D: 0, S: 0, R: 0 };
  const lines = t.split(/\n+/);
  const words = t.toLowerCase().split(/[\sï¼Œã€‚ã€â€œâ€â€˜â€™\-â€”:ï¼šï¼›;,.!?()ã€ã€‘\[\]<>]+/).filter(Boolean);
  const uniq = new Set(words);
  const uniqueRatio = uniq.size / Math.max(1, words.length);
  const whatIf = (t.match(/å¦‚æœ|ä¸å¦¨|å‡è®¾|what\s*if/gi) || []).length;
  const templates = (t.match(/\b(å…ˆ|é¦–å…ˆ|å…¶æ¬¡|ç„¶å|æœ€å|å› æ­¤|æ‰€ä»¥|ç„¶è€Œ|åŒæ—¶|å¦å¤–)\b|Because|Therefore|However/gi) || []).length;
  const bullets = lines.filter(l => /^\s*(\d+\.|[-â€¢Â·]|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\.|\*)/u.test(l)).length;
  const headings = lines.filter(l => /^\s*\d+\./.test(l)).length;
  const repeats = (()=>{ const freq = new Map(); words.forEach(w=>freq.set(w,(freq.get(w)||0)+1)); let rep=0; freq.forEach(v=>{ if(v>3) rep+=v-3; }); return rep/Math.max(1,words.length); })();
  const numeric = (t.match(/\d[%]?/g) || []).length;
  const evidence = (t.match(/æ•°æ®|æŒ‡æ ‡|é˜ˆå€¼|åä¾‹|éªŒè¯|å®éªŒ|æµ‹è¯•|é—¨æ§›|å¯è§‚æµ‹|åº¦é‡|é€šè¿‡/gu) || []).length;
  const musts = (t.match(/åº”å½“|å¿…é¡»|éœ€è¦/gu) || []).length;
  const D = Math.max(0, Math.min(1, 0.55*uniqueRatio + 0.25*Math.min(1, whatIf/6) + 0.20*Math.min(1, templates/12)));
  const S = Math.max(0, Math.min(1, 0.45*Math.min(1, headings/8) + 0.35*Math.min(1, bullets/16) + 0.30*Math.min(1, templates/20) - 0.20*repeats));
  const R = Math.max(0, Math.min(1, 0.45*Math.min(1, evidence/16) + 0.25*Math.min(1, numeric/20) + 0.30*(musts>0?1:0)));
  return { D:+D.toFixed(2), S:+S.toFixed(2), R:+R.toFixed(2) };
}

// â€”â€” çº¿ä»£å·¥å…·ï¼šæœ€å°äºŒä¹˜ Î”uï¼ˆå¸¦æŠ•å½±ï¼‰ â€”â€”
function matT(A){ const m=A.length,n=A[0].length; const T=Array.from({length:n},()=>Array(m).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) T[j][i]=A[i][j]; return T; }
function matMul(A,B){ const m=A.length,n=A[0].length,p=B[0].length; const C=Array.from({length:m},()=>Array(p).fill(0)); for(let i=0;i<m;i++) for(let k=0;k<n;k++) for(let j=0;j<p;j++) C[i][j]+=A[i][k]*B[k][j]; return C; }
function matVec(A,v){ return A.map(row=>row.reduce((s,val,i)=>s+val*v[i],0)); }
function solveSymmetric(A,b,lambda=1e-6){
  const n=A.length; const M=Array.from({length:n},(_,i)=>A[i].slice());
  for(let i=0;i<n;i++) M[i][i]+=lambda;
  const aug=M.map((row,i)=>row.concat([b[i]]));
  for(let i=0;i<n;i++){
    let piv=i; for(let r=i+1;r<n;r++) if(Math.abs(aug[r][i])>Math.abs(aug[piv][i])) piv=r;
    if(Math.abs(aug[piv][i])<1e-12) continue;
    if(piv!==i){ const tmp=aug[i]; aug[i]=aug[piv]; aug[piv]=tmp; }
    const div=aug[i][i]; for(let j=i;j<=n;j++) aug[i][j]/=div;
    for(let r=0;r<n;r++) if(r!==i){ const f=aug[r][i]; for(let j=i;j<=n;j++) aug[r][j]-=f*aug[i][j]; }
  }
  return aug.map(row=>row[n]);
}
function projectSimplex(u){ const v={...u}; const clamp=(x)=>Math.max(0,Math.min(1,x)); v.K=clamp(v.K); v.L=clamp(v.L); v.C=clamp(v.C); return normalizeKLC(v); }

// â€”â€” å°å·¥å…·ï¼šç»Ÿè®¡åˆ†ä½æ•°/é¢œè‰²æ˜ å°„ â€”â€”
function quantile(arr, q){ if(!arr.length) return 0; const a=[...arr].sort((x,y)=>x-y); const i=(a.length-1)*q; const lo=Math.floor(i), hi=Math.ceil(i); if(lo===hi) return a[lo]; const h=i-lo; return a[lo]*(1-h)+a[hi]*h; }
function colorScale01(v){ // 0=çº¢ 1=ç»¿
  const x=Math.max(0,Math.min(1, v));
  const hue= x*120; // 0..120
  return `hsl(${hue}, 70%, 55%)`;
}

export default function CockpitUseCases(){
  // â€”â€” SSR å®‰å…¨ â€”â€”
  const [isClient,setIsClient]=useState(false); useEffect(()=>setIsClient(true),[]);

  // â€”â€” æ¶ˆæ¯æ¡ â€”â€”
  const [msg,setMsg]=useState(null); const timerRef=useRef(null);
  const showMsg=(text,type="info")=>{ setMsg({text,type}); if(typeof window!=="undefined"){ if(timerRef.current) window.clearTimeout(timerRef.current); timerRef.current=window.setTimeout(()=>setMsg(null),3000);} };
  useEffect(()=>()=>{ if(timerRef.current) window.clearTimeout(timerRef.current); },[]);

  // ---- é»˜è®¤å€¼ ----
  const DEFAULT_SIMPLE={ ä¸ªäººæ•ˆç‡:8, å›¢é˜Ÿåä½œ:8, AIæŠ€æœ¯:9, ç¤¾ä¼šå†³ç­–:7, å“²å­¦æœªæ¥:9 };
  const DEFAULT_KLC={ K:0.62, L:0.33, C:0.05 }; // é»˜è®¤åé«˜åˆ›+ç»“æ„ã€ä½çº¦æŸ
  const DEFAULT_MODE="advanced"; // ç›´æ¥è¿›å…¥è¿›é˜¶
  const DEFAULT_PROFILE="creative";

  // ---- çŠ¶æ€ ----
  const [mode,setMode]=useState(DEFAULT_MODE);
  const [profile,setProfile]=useState(DEFAULT_PROFILE);
  const [values,setValues]=useState({...DEFAULT_SIMPLE});
  const [klc,setKlc]=useState({...DEFAULT_KLC});

  // API è°ƒç”¨å¼€å…³
  const [apiEnabled, setApiEnabled] = useState(false);

  // ---- æœ¬åœ°æŒä¹…åŒ– ----
  useEffect(()=>{ if(typeof window==="undefined") return; try{ const raw=localStorage.getItem(STORE_KEY); if(!raw) return; const saved=JSON.parse(raw);
    if(saved.mode) setMode(saved.mode);
    if(saved.profile && PROFILES[saved.profile]) setProfile(saved.profile);
    if(saved.values && typeof saved.values==="object") setValues({...DEFAULT_SIMPLE,...saved.values});
    if(saved.klc && typeof saved.klc==="object") setKlc(normalizeKLC({...DEFAULT_KLC,...saved.klc}));
    if(typeof saved.apiEnabled === "boolean") setApiEnabled(saved.apiEnabled);
    showMsg("å·²ä»æœ¬åœ°æ¢å¤é…ç½®","success");
  }catch(e){ console.warn("restore failed",e); } },[]);
  useEffect(()=>{ if(typeof window==="undefined") return; try{ localStorage.setItem(STORE_KEY, JSON.stringify({mode,profile,values,klc,apiEnabled})); }catch{} },[mode,profile,values,klc,apiEnabled]);

  // ---- æ˜ å°„ & é›·è¾¾ ----
  const mapping=useMemo(()=>mapKLCToApi(klc,profile),[klc,profile]);
  const radarData=[{layer:"ä¸ªäººæ•ˆç‡",value:values.ä¸ªäººæ•ˆç‡},{layer:"å›¢é˜Ÿåä½œ",value:values.å›¢é˜Ÿåä½œ},{layer:"AI æŠ€æœ¯",value:values.AIæŠ€æœ¯},{layer:"ç¤¾ä¼šå†³ç­–",value:values.ç¤¾ä¼šå†³ç­–},{layer:"å“²å­¦æœªæ¥",value:values.å“²å­¦æœªæ¥}];

  // ---- æ›´æ–°å™¨ & å® ----
  const setPart=(key,val)=>setKlc(normalizeKLC({...klc,[key]:val}));
  const resetSimple=()=>setValues({...DEFAULT_SIMPLE});
  const resetAdvanced=()=>setKlc({...DEFAULT_KLC});
  const applyMacroHiKHiLLoC=()=>{ const target=normalizeKLC({K:0.62,L:0.33,C:0.05}); setKlc(target); showMsg("å·²åº”ç”¨ï¼šåˆ›ç”Ÿâ†‘ ç»“æ„â†‘ çº¦æŸâ†“","success"); };
  const applyGate=()=>{ const next=normalizeKLC({K:klc.K*0.5, L:klc.L, C:Math.max(0.6, klc.C)}); setKlc(next); showMsg("å·²è¿›å…¥ Gateï¼šCâ‰ˆ0.6ï¼Œè¯·ç”Ÿæˆä¸€ç‰ˆæ”¶å£ç¨¿","success"); };

  // ---- ç¦»çº¿æ¨¡æ‹Ÿ / APIï¼ˆAPI éƒ¨åˆ†ä¿ç•™å¯é€‰ï¼‰ ----
  const [simPrompt,setSimPrompt]=useState("");
  const [simText,setSimText]=useState("");
  const [response,setResponse]=useState("");
  const [isLoading,setIsLoading]=useState(false);
  const [error,setError]=useState(null);
  const [apiKey,setApiKey]=useState("");

  // ---- æŒ‡æ ‡ä¸å†å²ï¼ˆç”¨äº Barrier/Gateï¼‰ ----
  const [lastMetrics,setLastMetrics]=useState({D:0,S:0,R:0});
  const [history,setHistory]=useState([]); // [{u:{K,L,C}, m:{D,S,R}, source:"offline|api", t:number, note?:string}]
  const [runCount,setRunCount]=useState(0);

  const pushHistory=(u,m,source,note)=>{
    setLastMetrics(m);
    setHistory(h=>[...h,{u:{...u},m:{...m},source, t:Date.now(), note}]);
    setRunCount(c=>c+1);
  };

  // ---- æŒ‡æ ‡é¢æ¿ï¼ˆä¼˜å…ˆä½¿ç”¨ simTextï¼Œå¦åˆ™ API responseï¼‰ ----
  const currentText = simText || response || "";
  const metrics = useMemo(()=>computeMetrics(currentText),[currentText]);

  // ---- Barrierï¼šR ä¸¤è½®ä½äºé˜ˆå€¼ â†’ è‡ªåŠ¨æŠ¬ Câ‰¥0.35 ----
  const SPRINT_R_MIN=0.30; const GATE_R_MIN=0.60;
  useEffect(()=>{
    if(history.length<2) return;
    const n=history.length; const r1=history[n-1].m.R; const r2=history[n-2].m.R;
    if(r1<SPRINT_R_MIN && r2<SPRINT_R_MIN){
      const next=normalizeKLC({K:klc.K*0.8, L:klc.L*0.8, C:Math.max(0.35, klc.C)});
      setKlc(next);
      showMsg("Barrier è§¦å‘ï¼šå¯è¯åº¦è¿ç»­åä½ï¼Œå·²è‡ªåŠ¨æé«˜ C è‡³ â‰¥0.35","error");
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  },[history]);

  // ---- Gate æç¤ºï¼šæ¯ 3 è½®æé†’è¿›å…¥æ”¶å£ï¼ˆCâ‰ˆ0.6ï¼‰ ----
  useEffect(()=>{
    if(runCount>0 && runCount%3===0){ showMsg("å»ºè®®è¿›å…¥ Gateï¼šå°† C æè‡³ ~0.6 åšæ”¶å£å°ç»“","info"); }
  },[runCount]);

  // ---- å¾®æ‰«æï¼šÂ±0.05ï¼Œä¼°è®¡ G ä¸å»ºè®® Î”u ----
  const [scan,setScan]=useState(null); // v1 çº¿æ€§
  function microScan(delta=0.05){
    const baseU={...klc};
    const prompt = simPrompt || "ç¤ºä¾‹ï¼šä»¥å½“å‰ä¸»é¢˜ç”Ÿæˆä¸€ç‰ˆç»“æ„åŒ–éª¨æ¶";
    const m0 = computeMetrics(simulateTextOffline(prompt, baseU, PROFILES[profile].label));
    const dirs=["K","L","C"];
    const col=[]; // 3 åˆ—
    for(const d of dirs){
      const up = normalizeKLC({...baseU, [d]: Math.min(0.999, baseU[d]+delta)});
      const dn = normalizeKLC({...baseU, [d]: Math.max(0.001, baseU[d]-delta)});
      const mp = computeMetrics(simulateTextOffline(prompt, up, PROFILES[profile].label));
      const mn = computeMetrics(simulateTextOffline(prompt, dn, PROFILES[profile].label));
      col.push([(mp.D-mn.D)/(2*delta), (mp.S-mn.S)/(2*delta), (mp.R-mn.R)/(2*delta)]);
    }
    const G=[[col[0][0],col[1][0],col[2][0]],[col[0][1],col[1][1],col[2][1]],[col[0][2],col[1][2],col[2][2]]];
    const target = {D:0.75, S:0.70, R:0.35};
    const e=[target.D - m0.D, target.S - m0.S, target.R - m0.R];
    const GT = matT(G); const GTG = matMul(GT,G); const GTe = matVec(GT,e);
    const x = solveSymmetric(GTG, GTe, 1e-5); // æœ€å°äºŒä¹˜è§£ Î”u
    const eta=0.5; // æ­¥é•¿
    const suggestRaw={K: baseU.K + eta*x[0], L: baseU.L + eta*x[1], C: baseU.C + eta*x[2]};
    const suggest=projectSimplex(suggestRaw);
    const mostEffectiveIndex = [Math.abs(G[0][0])+Math.abs(G[1][0])+Math.abs(G[2][0]), Math.abs(G[0][1])+Math.abs(G[1][1])+Math.abs(G[2][1]), Math.abs(G[0][2])+Math.abs(G[1][2])+Math.abs(G[2][2])].reduce((best,cur,i)=> cur>best.val?{val:cur,idx:i}:best,{val:-1,idx:0});
    const knob=["K(åˆ›ç”Ÿ)","L(ç»“æ„)","C(çº¦æŸ)"][mostEffectiveIndex.idx];
    setScan({G, suggest, note:`æ­¤åˆ»æœ€æœ‰æ•ˆæ‹¨æ†ï¼š${knob}`});
    showMsg("å·²å®Œæˆå¾®æ‰«æï¼Œç»™å‡ºå»ºè®®æ‹¨æ†","success");
  }
  const applyScanSuggestion=()=>{ if(scan?.suggest){ setKlc(scan.suggest); showMsg("å·²åº”ç”¨å»ºè®®æ‹¨æ†","success"); } };

  // ---- å¾®æ‰«æ 2.0ï¼šåŒå˜é‡äº¤äº’ + ä¿¡èµ–åŸŸï¼ˆtrust-regionï¼‰ ----
  const [scan2, setScan2] = useState(null); // {suggest, coupling, radius, note}

  function estimateJacobian(baseU, prompt, delta){
    const dirs=["K","L","C"]; const col=[];
    for(const d of dirs){
      const up = normalizeKLC({...baseU, [d]: Math.min(0.999, baseU[d]+delta)});
      const dn = normalizeKLC({...baseU, [d]: Math.max(0.001, baseU[d]-delta)});
      const mp = computeMetrics(simulateTextOffline(prompt, up, PROFILES[profile].label));
      const mn = computeMetrics(simulateTextOffline(prompt, dn, PROFILES[profile].label));
      col.push([(mp.D-mn.D)/(2*delta), (mp.S-mn.S)/(2*delta), (mp.R-mn.R)/(2*delta)]);
    }
    return [[col[0][0],col[1][0],col[2][0]],[col[0][1],col[1][1],col[2][1]],[col[0][2],col[1][2],col[2][2]]];
  }

  function estimateMixedMatrix(baseU, prompt, delta){
    // è¿”å›ä¸‰ä¸ªæŒ‡æ ‡çš„æ··åˆäºŒé˜¶é¡¹çš„ç»å¯¹å€¼åŠ æƒå’Œï¼ˆç”¨äºæƒ©ç½šè€¦åˆï¼‰
    const pairs=[["K","L"],["L","C"],["C","K"]];
    const idx={K:0,L:1,C:2};
    const W={D:0.3,S:0.35,R:0.35}; // å¼ºè°ƒ S/R ç¨³å®š
    // åˆå§‹åŒ– 3x3 å…¨ 0
    const Agg=[[0,0,0],[0,0,0],[0,0,0]];

    function metricFromText(text){ return computeMetrics(text); }

    for(const [a,b] of pairs){
      const upup = normalizeKLC({...baseU, [a]: Math.min(0.999, baseU[a]+delta), [b]: Math.min(0.999, baseU[b]+delta)});
      const updn = normalizeKLC({...baseU, [a]: Math.min(0.999, baseU[a]+delta), [b]: Math.max(0.001, baseU[b]-delta)});
      const dnup = normalizeKLC({...baseU, [a]: Math.max(0.001, baseU[a]-delta), [b]: Math.min(0.999, baseU[b]+delta)});
      const dndn = normalizeKLC({...baseU, [a]: Math.max(0.001, baseU[a]-delta), [b]: Math.max(0.001, baseU[b]-delta)});
      const m1 = metricFromText(simulateTextOffline(prompt, upup, PROFILES[profile].label));
      const m2 = metricFromText(simulateTextOffline(prompt, updn, PROFILES[profile].label));
      const m3 = metricFromText(simulateTextOffline(prompt, dnup, PROFILES[profile].label));
      const m4 = metricFromText(simulateTextOffline(prompt, dndn, PROFILES[profile].label));
      const hD = Math.abs((m1.D - m2.D - m3.D + m4.D) / (4*delta*delta));
      const hS = Math.abs((m1.S - m2.S - m3.S + m4.S) / (4*delta*delta));
      const hR = Math.abs((m1.R - m2.R - m3.R + m4.R) / (4*delta*delta));
      const val = W.D*hD + W.S*hS + W.R*hR; // èšåˆ
      const i=idx[a], j=idx[b];
      Agg[i][j]+=val; Agg[j][i]+=val; // å¯¹ç§°
    }
    // è½»å¾®å¯¹è§’æ­£åˆ™ï¼Œé˜²æ­¢å¥‡å¼‚
    for(let i=0;i<3;i++){ Agg[i][i] += 1e-3; }
    return Agg; // 3x3
  }

  function microScan2(delta=0.05, radius=0.12){
    const baseU={...klc};
    const prompt = simPrompt || "ç¤ºä¾‹ï¼šä»¥å½“å‰ä¸»é¢˜ç”Ÿæˆä¸€ç‰ˆç»“æ„åŒ–éª¨æ¶";
    const m0 = computeMetrics(simulateTextOffline(prompt, baseU, PROFILES[profile].label));

    // 1) ä¸€é˜¶ï¼šé›…å¯æ¯” G
    const G = estimateJacobian(baseU, prompt, delta);

    // 2) äºŒé˜¶ï¼šæ··åˆè€¦åˆæƒ©ç½šçŸ©é˜µï¼ˆç»å¯¹å€¼åŠ æƒï¼‰
    const C = estimateMixedMatrix(baseU, prompt, delta);

    // 3) ç›®æ ‡ä¸æœ€å°äºŒä¹˜ï¼ˆä¿¡èµ–åŸŸ + è€¦åˆæƒ©ç½šï¼‰
    const target = {D:0.75, S:0.70, R:0.35};
    const e=[target.D - m0.D, target.S - m0.S, target.R - m0.R];
    const GT = matT(G); const GTG = matMul(GT,G); const GTe = matVec(GT,e);
    // ç»„åˆï¼šA = GTG + lambda * C
    const lambda = 0.3; // è€¦åˆæƒ©ç½šæƒé‡
    const A = [[GTG[0][0]+lambda*C[0][0], GTG[0][1]+lambda*C[0][1], GTG[0][2]+lambda*C[0][2]],
              [GTG[1][0]+lambda*C[1][0], GTG[1][1]+lambda*C[1][1], GTG[1][2]+lambda*C[1][2]],
              [GTG[2][0]+lambda*C[2][0], GTG[2][1]+lambda*C[2][1], GTG[2][2]+lambda*C[2][2]]];
    let x = solveSymmetric(A, GTe, 1e-5);

    // 4) ä¿¡èµ–åŸŸï¼šé™åˆ¶æ­¥é•¿
    const norm = Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]) || 1;
    if(norm > radius){ x = x.map(v=> v * (radius / norm)); }

    const eta=0.8; // 2.0 ç”¨æ›´å¤§èƒ†æ­¥é•¿ï¼Œä½†ä»æŠ•å½±
    const suggestRaw={K: baseU.K + eta*x[0], L: baseU.L + eta*x[1], C: baseU.C + eta*x[2]};
    const suggest = projectSimplex(suggestRaw);

    // 5) äº¤äº’å¼ºåº¦è¯»æ•°ï¼ˆ0..1 å½’ä¸€åŒ–ï¼‰
    const offdiag=[C[0][1],C[1][2],C[2][0]]; const maxv=Math.max(...offdiag,1e-6);
    const coupling={
      "KÃ—L": +(C[0][1]/maxv).toFixed(2),
      "LÃ—C": +(C[1][2]/maxv).toFixed(2),
      "CÃ—K": +(C[2][0]/maxv).toFixed(2),
    };

    setScan2({suggest, coupling, radius, note:"å·²è€ƒè™‘åŒå˜é‡è€¦åˆå¹¶çº¦æŸæ­¥é•¿"});
    showMsg("å¾®æ‰«æ 2.0 å®Œæˆï¼šå·²è€ƒè™‘äº¤äº’é¡¹ä¸ä¿¡èµ–åŸŸ","success");
  }

  const applyScan2Suggestion=()=>{ if(scan2?.suggest){ setKlc(scan2.suggest); showMsg("å·²åº”ç”¨å¾®æ‰«æ 2.0 å»ºè®®","success"); } };

  // ---- å¤åˆ¶ API å‚æ•° ----
  const copyApiParams=async()=>{ const payload=JSON.stringify({profile, ...mapping},null,2); try{ await navigator.clipboard.writeText(payload); showMsg("å·²å¤åˆ¶ API å‚æ•°åˆ°å‰ªè´´æ¿","success"); }catch(err){ try{ const ta=document.createElement("textarea"); ta.value=payload; document.body.appendChild(ta); ta.select(); document.execCommand("copy"); document.body.removeChild(ta); showMsg("å·²å¤åˆ¶ï¼ˆå…¼å®¹æ¨¡å¼ï¼‰","success"); }catch(e){ showMsg("å¤åˆ¶å¤±è´¥ï¼š"+String(e||err),"error"); } } };

  // ---- è‡ªæµ‹ç”¨ä¾‹ ----
  const [tests,setTests]=useState([]);
  const runSelfTests=()=>{
    const out=[]; const approx=(a,b,eps=1e-6)=>Math.abs(a-b)<eps;
    const n1=normalizeKLC({K:0.4,L:0.4,C:0.2}); out.push({name:"normalize sum=1",pass:approx(n1.K+n1.L+n1.C,1)});
    const mk0=mapKLCToApi({K:0,L:0.5,C:0.5},"creative"); out.push({name:"creative: K=0 â†’ tâ‰ˆtMin",pass:approx(mk0.temperature,PROFILES.creative.tMin)});
    const mk1=mapKLCToApi({K:1,L:1,C:0},"creative"); out.push({name:"creative: K=1 â†’ tâ‰ˆtMax",pass:approx(mk1.temperature,PROFILES.creative.tMax)});
    const macro=normalizeKLC({K:0.62,L:0.33,C:0.05}); out.push({name:"macro sum=1",pass:approx(macro.K+macro.L+macro.C,1)});
    const prj=projectSimplex({K:1.2,L:-0.1,C:0.1}); out.push({name:"project to simplex",pass:approx(prj.K+prj.L+prj.C,1) && prj.K>=0 && prj.L>=0 && prj.C>=0});
    const G=[[1,0,0],[0,1,0],[0,0,1]], e=[0.1,-0.2,0.3]; const GT=matT(G),GTG=matMul(GT,G),x=solveSymmetric(GTG,matVec(GT,e),1e-6); out.push({name:"LS solve sanity",pass:approx(x[0],0.1)&&approx(x[1],-0.2)&&approx(x[2],0.3)});
    // MBG æµ‹è¯•
    const a="æµ‹è¯•A æ–‡æœ¬", b="æµ‹è¯•A æ–‡æœ¬"; const A=tfVectorize(tokenizeWords(a)), B=tfVectorize(tokenizeWords(b)); const simSame=cosineSim(A,B); out.push({name:"MBG åŒæ–‡â‰ˆ0", pass:(1-simSame)<=0.05});
    const c="å®Œå…¨ä¸åŒçš„ä¸»é¢˜", d="quantum mechanics and tensors"; const C=tfVectorize(tokenizeWords(c)), Dv=tfVectorize(tokenizeWords(d)); const simDiff=cosineSim(C,Dv); out.push({name:"MBG å¼‚æ–‡>0.5", pass:(1-simDiff)>0.5});
    setTests(out); showMsg("å·²è¿è¡Œè‡ªæµ‹ç”¨ä¾‹ï¼ˆ8 é¡¹ï¼‰","success");
  };

  // ---- ç”Ÿæˆï¼šç¦»çº¿ & APIï¼ˆAPI å¯é€‰ï¼‰ ----
  const runOfflineSim=()=>{
    const txt=simulateTextOffline(simPrompt, klc, PROFILES[profile].label);
    setSimText(txt);
    const m=computeMetrics(txt); pushHistory(klc,m,"offline");
    showMsg("å·²ç”¨å½“å‰ K/L/C ç”Ÿæˆç¦»çº¿æ¨¡æ‹Ÿæ–‡æœ¬","success");
  };

  const generateText=async()=>{
    setIsLoading(true); setError(null); setResponse("");
    const cleaned = sanitizeText(simPrompt || "").trim();
    if(!cleaned){ setError("è¯·è¾“å…¥æç¤ºè¯ã€‚"); setIsLoading(false); return; }
    if(!apiEnabled){ setError("API å¼€å…³æœªå¼€å¯ã€‚ä½ ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ä¸Šæ–¹çš„ç¦»çº¿æ¨¡æ‹Ÿè¾“å‡ºã€‚"); setIsLoading(false); return; }
    if(!apiKey){ setError("æœªé…ç½® API Keyã€‚æ­¤åŠŸèƒ½å¯é€‰ï¼Œç¦»çº¿æ¨¡æ‹Ÿå·²å¯ç”¨ã€‚"); setIsLoading(false); return; }
    const apiUrl=`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
    const payload={ contents:[{parts:[{text:cleaned}]}], generationConfig:{temperature:mapping.temperature, topP:mapping.top_p, maxOutputTokens:mapping.max_tokens} };
    try{
      const res=await fetch(apiUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(payload)});
      if(!res.ok){ const errData=await res.json().catch(()=>({})); throw new Error(errData?.error?.message || `API error: ${res.status}`); }
      const result=await res.json(); const text=result?.candidates?.[0]?.content?.parts?.[0]?.text;
      if(text){ setResponse(text); const m=computeMetrics(text); pushHistory(klc,m,"api"); } else { setError("æ— æ³•ç”Ÿæˆå“åº”ï¼ˆå¯èƒ½è§¦å‘å®‰å…¨ç­–ç•¥ï¼‰ã€‚"); }
    }catch(e){ setError(e.message || "è¯·æ±‚å¤±è´¥ã€‚"); }
    finally{ setIsLoading(false); }
  };

  // ================= é»‘ç®±å¯è§†åŒ–ï¼šçŠ¶æ€ä¸è®¡ç®— =================
  const [vizRunning,setVizRunning]=useState(false);
  const [ribbonStats,setRibbonStats]=useState(null); // {D:{p10,p50,p90,mean},S:{...},R:{...}}
  const [importance,setImportance]=useState(null);   // [{token,score}]
  const [heatMetric,setHeatMetric]=useState("R");    // "D"|"S"|"R"
  const [heatData,setHeatData]=useState(null);       // {D:number[][], S:number[][], R:number[][], ks:number[], cs:number[]}

  function tokenizeForImportance(text){
    const t = sanitizeText(text||"");
    const tokens = t.match(/[\u4e00-\u9fa5]|[A-Za-z0-9]+|\s+|[^\s\w]/g) || [];
    // é™åˆ¶é•¿åº¦ï¼Œé¿å…è¿‡é‡
    if(tokens.length>200) return tokens.slice(0,200);
    return tokens;
  }

  function runVisuals(){
    const prompt = simPrompt || "ç¤ºä¾‹ï¼šä»¥å½“å‰ä¸»é¢˜ç”Ÿæˆä¸€ç‰ˆç»“æ„åŒ–éª¨æ¶";
    setVizRunning(true);
    try{
      // 1) å¤šæ¬¡ç”Ÿæˆç¼å¸¦ï¼ˆN=7ï¼‰
      const N=7; const valsD=[], valsS=[], valsR=[];
      for(let i=0;i<N;i++){
        const txt=simulateTextOffline(prompt, klc, PROFILES[profile].label, i);
        const m=computeMetrics(txt);
        valsD.push(m.D); valsS.push(m.S); valsR.push(m.R);
      }
      const stats=(arr)=>({ p10:+quantile(arr,0.10).toFixed(2), p50:+quantile(arr,0.50).toFixed(2), p90:+quantile(arr,0.90).toFixed(2), mean:+(arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(2) });
      setRibbonStats({ D:stats(valsD), S:stats(valsS), R:stats(valsR) });

      // 2) è¯é‡è¦åº¦ï¼ˆé®è”½æ³•ï¼ŒåŸºäºå½“å‰æ–‡æœ¬æˆ–æœ€æ–°æ¨¡æ‹Ÿï¼‰
      let baseText = currentText;
      if(!baseText){ baseText = simulateTextOffline(prompt, klc, PROFILES[profile].label, 123); setSimText(baseText); }
      const baseM = computeMetrics(baseText);
      const tokens = tokenizeForImportance(baseText);
      const imp=[]; const wD=0.2,wS=0.3,wR=0.5;
      for(let i=0;i<tokens.length;i++){
        const alt = tokens.slice(0,i).join("") + tokens.slice(i+1).join("");
        const m = computeMetrics(alt);
        const score = Math.abs(m.D-baseM.D)*wD + Math.abs(m.S-baseM.S)*wS + Math.abs(m.R-baseM.R)*wR;
        imp.push({ token: tokens[i], score:+score.toFixed(3) });
      }
      setImportance(imp);

      // 3) (KÃ—C) çƒ­åŠ›å›¾ï¼ˆå›ºå®š Lï¼Œå½’ä¸€åŒ–åä¿æŒæ¯”ä¾‹ï¼‰
      const GRID=7; const ks=[], cs=[];
      for(let i=0;i<GRID;i++){ ks.push(i/(GRID-1)); }
      for(let j=0;j<GRID;j++){ cs.push(j/(GRID-1)); }
      const gridD=[], gridS=[], gridR=[];
      const Lfix = Math.max(0, Math.min(1, klc.L));
      const rem = Math.max(1e-6, 1 - Lfix);
      for(let i=0;i<GRID;i++){
        const rowD=[], rowS=[], rowR=[];
        for(let j=0;j<GRID;j++){
          // åŒè½´ä½œä¸º K ä¸ C çš„ç›¸å¯¹å æ¯”ï¼Œå†åœ¨ (1-L) å†…æŒ‰æ¯”ä¾‹åˆ†é…ï¼Œç¡®ä¿ L å›ºå®š
          const kr = ks[i], cr = cs[j];
          const denom = Math.max(1e-9, kr + cr);
          const K = rem * (kr / denom);
          const C = rem * (cr / denom);
          const cand = { K, L: Lfix, C };
          const txt=simulateTextOffline(prompt, cand, PROFILES[profile].label, i*37+j*11);
          const m=computeMetrics(txt);
          rowD.push(m.D); rowS.push(m.S); rowR.push(m.R);
        }
        gridD.push(rowD); gridS.push(rowS); gridR.push(rowR);
      }
      setHeatData({D:gridD, S:gridS, R:gridR, ks, cs});

      pushHistory(klc, metrics, "offline", "è¿è¡Œå¯è§†åŒ–");
      showMsg("é»‘ç®±å¯è§†åŒ–è®¡ç®—å®Œæˆ","success");
    }catch(e){
      console.error(e);
      showMsg("å¯è§†åŒ–è®¡ç®—å¤±è´¥ï¼š"+String(e&&e.message?e.message:e),"error");
    }finally{
      setVizRunning(false);
    }
  }

  // ---- UI ----
  // ---- æ­£äº¤è½´ï¼ˆSVD on Jacobianï¼‰+ è‡ªç„¶æ¢¯åº¦ / Doubt Suite / Gate ----
  const [svd, setSvd] = useState(null); // {V:number[3][3], sigma:number[3]}
  const [natGrad, setNatGrad] = useState({enabled:false, alphaR:0.4, betaS:0.3, gammaD:0.1, lr:0.6});
  const [doubt, setDoubt] = useState(null);
  // é«˜çº§é˜ˆå€¼ & è½´æ­¥é•¿ï¼ˆä¸æœ¬åœ°æŒä¹…åŒ–é…åˆï¼‰
  const [gateThr, setGateThr] = useState({ R: 0.60, CD: 0.65, MBG: 0.25 });
  const [axisSteps, setAxisSteps] = useState({ a1: 0.08, a2: 0.06, a3: 0.04 }); // {lower:{D,S,R,CD}, cases:[...]}

  // â€”â€” æ„å›¾å¯¹é½ï¼ˆMBG = 1 - cosï¼‰ â€”â€”
  const [intentText, setIntentText] = useState("");
  const [mbg, setMbg] = useState(null); // 0..1
  function tokenizeWords(s){ const t=sanitizeText(s||"").toLowerCase(); return t.match(/[ä¸€-é¾¥]|[a-z0-9]+/gi) || []; }
  function tfVectorize(tokens){ const m=new Map(); tokens.forEach(w=>m.set(w,(m.get(w)||0)+1)); return m; }
  function cosineSim(mapA,mapB){ let dot=0,na=0,nb=0; const keys=new Set([...mapA.keys(),...mapB.keys()]); keys.forEach(k=>{ const a=mapA.get(k)||0,b=mapB.get(k)||0; dot+=a*b; na+=a*a; nb+=b*b; }); if(na===0||nb===0) return 0; return dot/Math.sqrt(na*nb); }
  function computeMBG(){
    const intent=intentText.trim(); const text=(simText||response||"").trim();
    if(!intent||!text){ setMbg(null); showMsg("è¯·è¾“å…¥æ„å›¾æ–‡æœ¬ï¼Œå¹¶ç”Ÿæˆ/ç²˜è´´å½“å‰æ–‡æœ¬åå†è¯•","error"); return; }
    const A=tfVectorize(tokenizeWords(intent)); const B=tfVectorize(tokenizeWords(text));
    const sim=cosineSim(A,B); const mbgVal=+(1-sim).toFixed(2); setMbg(mbgVal);
    showMsg(`å·²è®¡ç®— MBGï¼ˆæ„å›¾-æˆæ–‡å·®è·ï¼‰=${mbgVal}`,"success");
  }

  function vecDot(a,b){let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s;}
  function vecNorm(a){return Math.sqrt(Math.max(1e-12, vecDot(a,a)));}
  function vecScale(a,k){return a.map(x=>x*k);} 
  function vecAdd(a,b){return a.map((x,i)=>x+b[i]);}
  // å¤ç”¨å‰é¢å·²å®šä¹‰çš„ matVec(A,v)

  function topEigen(M, iters=40){
    let v=[1,0,0];
    for(let i=0;i<iters;i++){ v = matVec(M,v); const n=vecNorm(v); v = n>0? v.map(x=>x/n):[1,0,0]; }
    const lambda = vecDot(v, matVec(M,v));
    return {val:lambda, vec:v};
  }
  function deflate(M, eig){
    const {val, vec:v}=eig; const d=[[v[0]*v[0], v[0]*v[1], v[0]*v[2]],[v[1]*v[0], v[1]*v[1], v[1]*v[2]],[v[2]*v[0], v[2]*v[1], v[2]*v[2]]];
    const out=[[],[],[]];
    for(let i=0;i<3;i++) for(let j=0;j<3;j++) out[i][j]=M[i][j]-val*d[i][j];
    return out;
  }
  function eigenSym3(M){
    const e1=topEigen(M); const M2=deflate(M,e1);
    const e2=topEigen(M2); const M3=deflate(M2,e2);
    const e3=topEigen(M3);
    const arr=[e1,e2,e3].map(e=>({val:Math.max(0,e.val), vec:vecScale(e.vec, 1/vecNorm(e.vec))}))
                      .sort((a,b)=>b.val-a.val);
    return {vals:arr.map(x=>x.val), vecs:arr.map(x=>x.vec)};
  }
  function computeOrthogonalAxes(delta=0.05){
    const baseU={...klc};
    const prompt = simPrompt || "ç¤ºä¾‹ï¼šä»¥å½“å‰ä¸»é¢˜ç”Ÿæˆä¸€ç‰ˆç»“æ„åŒ–éª¨æ¶";
    const G = estimateJacobian(baseU, prompt, delta);
    const GT = matT(G); const GTG = matMul(GT,G);
    const eig = eigenSym3(GTG);
    const sigma = eig.vals.map(v=>Math.sqrt(Math.max(0,v)));
    const V = eig.vecs; setSvd({V, sigma});
    showMsg("å·²è®¡ç®—æ­£äº¤æ‹¨æ†è½´ï¼ˆAxis-1/2/3ï¼‰","success");
  }
  function stepAlongAxis(axis=0, step=0.08){
    if(!svd){ computeOrthogonalAxes(); return; }
    const dir=[svd.V[axis][0], svd.V[axis][1], svd.V[axis][2]];
    const suggestRaw = {K: klc.K + step*dir[0], L: klc.L + step*dir[1], C: klc.C + step*dir[2]};
    const suggest = projectSimplex(suggestRaw);
    setKlc(suggest);
    showMsg(`å·²æ²¿ Axis-${axis+1} å‰è¿›`, "success");
  }
  function softmax3(x){ const m=Math.max(...x); const ex=x.map(v=>Math.exp(v-m)); const s=ex[0]+ex[1]+ex[2]; return ex.map(v=>v/s); }
  function applyNaturalGradStep(delta=0.05){
    const baseU={...klc};
    const prompt = simPrompt || "ç¤ºä¾‹ï¼šä»¥å½“å‰ä¸»é¢˜ç”Ÿæˆä¸€ç‰ˆç»“æ„åŒ–éª¨æ¶";
    const G = estimateJacobian(baseU, prompt, delta);
    const wOut=[natGrad.gammaD, natGrad.betaS, natGrad.alphaR];
    const grad = matVec(matT(G), wOut);
    const theta=[Math.log(klc.K+1e-9), Math.log(klc.L+1e-9), Math.log(klc.C+1e-9)];
    const next = softmax3([theta[0]+natGrad.lr*grad[0], theta[1]+natGrad.lr*grad[1], theta[2]+natGrad.lr*grad[2]]);
    setKlc({K:next[0], L:next[1], C:next[2]});
    showMsg("å·²åº”ç”¨è‡ªç„¶æ¢¯åº¦æ­¥è¿›ï¼ˆsoftmax çº¦æŸï¼‰","success");
  }
  function runDoubtSuite(){
    const baseU={...klc};
    const prompt = simPrompt || "ç¤ºä¾‹ï¼šä»¥å½“å‰ä¸»é¢˜ç”Ÿæˆä¸€ç‰ˆç»“æ„åŒ–éª¨æ¶";
    const seeds=[101,202,303]; const cases=[]; let lower={D:1,S:1,R:1,CD:1};
    for(const s of seeds){
      const txt = simulateTextOffline(prompt, baseU, PROFILES[profile].label, s);
      const m = computeMetrics(txt);
      const CD = Math.max(0, Math.min(1, 0.6*m.R + 0.4*m.S));
      lower={D:Math.min(lower.D,m.D), S:Math.min(lower.S,m.S), R:Math.min(lower.R,m.R), CD:Math.min(lower.CD,CD)};
      cases.push({seed:s, ...m, CD});
    }
    setDoubt({lower, cases});
    showMsg("å·²å®Œæˆ Doubt Suiteï¼ˆå–æœ€åä¸€æ¡£ï¼‰","success");
  }
  function evalRobustGate(){
    if(!doubt){ showMsg("è¯·å…ˆè¿è¡Œ Doubt Suite","error"); return; }
    const okCore = (doubt.lower.R>=gateThr.R) && (doubt.lower.CD>=gateThr.CD);
    const okMBG = (mbg==null) ? true : (mbg<=gateThr.MBG);
    const ok = okCore && okMBG;
    const reason = ok ? `Gate é€šè¿‡ï¼ˆé²æ£’${mbg==null?"":"Â·å¯¹é½"}ï¼‰` : (!okCore ? "Gate æœªè¿‡ï¼šR/CD ä¸‹ç•Œä¸è¶³" : "Gate æœªè¿‡ï¼šMBG è¶…é˜ˆå€¼ï¼Œæ„å›¾ä¸æˆæ–‡ä¸å¯¹é½");
    showMsg(reason, ok?"success":"error");
  }

  // â€”â€” æŒä¹…åŒ–ï¼ˆé«˜çº§è®¾ç½®ï¼Œç‹¬ç«‹é”®ï¼‰ â€”â€”
  useEffect(()=>{ if(typeof window==="undefined") return; try{ const raw=localStorage.getItem(STORE_KEY+":adv"); if(!raw) return; const s=JSON.parse(raw); if(s.natGrad) setNatGrad(v=>({...v,...s.natGrad})); if(s.gateThr) setGateThr(t=>({...t,...s.gateThr})); if(s.axisSteps) setAxisSteps(a=>({...a,...s.axisSteps})); showMsg("å·²æ¢å¤é«˜çº§è®¾ç½®","success"); }catch{} },[]);
  useEffect(()=>{ if(typeof window==="undefined") return; try{ localStorage.setItem(STORE_KEY+":adv", JSON.stringify({natGrad, gateThr, axisSteps})); }catch{} }, [natGrad, gateThr, axisSteps]);

  return (
    <div className="p-6 space-y-6">
      {msg && (
        <div className={`rounded-md p-3 text-sm ${ msg.type==="success"?"bg-green-50 text-green-700 border border-green-200": msg.type==="error"?"bg-red-50 text-red-700 border border-red-200": "bg-gray-50 text-gray-700 border border-gray-200" }`}>
          {msg.text}
        </div>
      )}

      {/* æ¨¡å¼ & Profile */}
      <Card>
        <CardContent className="p-4 space-y-4">
          <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
            <h2 className="text-2xl font-bold">é©¾é©¶èˆ±ï¼šK/L/C + æŒ‡æ ‡æ§åˆ¶</h2>
            <div className="flex flex-wrap gap-2">
              <Button variant={mode==="simple"?"default":"outline"} onClick={()=>setMode("simple")}>ç®€å•æ¨¡å¼</Button>
              <Button variant={mode==="advanced"?"default":"outline"} onClick={()=>setMode("advanced")}>è¿›é˜¶æ¨¡å¼</Button>
              <span className="w-px h-6 bg-gray-200 mx-1 hidden md:inline-block" />
              {Object.entries(PROFILES).map(([k,p])=> (
                <Button key={k} variant={profile===k?"default":"outline"} onClick={()=>setProfile(k)}>{p.label}</Button>
              ))}
            </div>
          </div>
          <p className="text-sm text-gray-600">Creativeï¼ˆæ›´å‘æ•£ï¼‰/ Factualï¼ˆæ›´ä¿å®ˆï¼‰/ Codeï¼ˆæœ€ä¿å®ˆï¼‰ã€‚æ¯ 3 è½®å»ºè®® Gate æ”¶å£ï¼ŒR ä½ä¸¤è½®è§¦å‘ Barrier è‡ªåŠ¨å‡ Cã€‚</p>
        </CardContent>
      </Card>

      {/* åœºæ™¯æ¸…å•ï¼ˆç®€ï¼‰ */}
      <Card>
        <CardContent className="p-4 space-y-2">
          <h2 className="text-lg font-semibold">å…¸å‹åœºæ™¯</h2>
          <p className="text-sm text-gray-700">æ–¹æ¡ˆè“å›¾ã€æ¼”è®²å¤§çº²ã€è·¯æ¼”éª¨æ¶ã€ç ”ç©¶ç»¼è¿°ã€è¯¾ç¨‹è®®ç¨‹ã€å“ç‰Œ Campaignã€OKR è§„åˆ’ç­‰ã€‚</p>
        </CardContent>
      </Card>

      {/* ç®€å•æ¨¡å¼ */}
      {mode==="simple" && (
        <Card>
          <CardContent className="p-4 space-y-6">
            <div className="flex items-center justify-between gap-2">
              <h2 className="text-xl font-bold">äº”å±‚èºæ—‹ Â· é›·è¾¾å›¾ï¼ˆç®€å•æ¨¡å¼ï¼‰</h2>
              <Button variant="outline" onClick={()=>{ resetSimple(); showMsg("å·²é‡ç½®é»˜è®¤å€¼","success"); }}>é‡ç½®é»˜è®¤å€¼</Button>
            </div>
            {isClient && (
              <ResponsiveContainer width="100%" height={360}>
                <RadarChart cx="50%" cy="50%" outerRadius="80%" data={radarData}>
                  <PolarGrid />
                  <PolarAngleAxis dataKey="layer" />
                  <Radar name="ä»·å€¼å¼ºåº¦" dataKey="value" stroke="#6366f1" fill="#6366f1" fillOpacity={0.6} />
                </RadarChart>
              </ResponsiveContainer>
            )}
            <div className="space-y-4">
              {Object.keys(values).map(k=> (
                <div key={k}>
                  <label className="block text-sm font-medium text-gray-700">{k}: {values[k]}</label>
                  <Slider value={[values[k]]} onValueChange={(val)=>setValues({...values,[k]:val[0]})} min={0} max={10} step={1} />
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* è¿›é˜¶æ¨¡å¼ */}
      {mode==="advanced" && (
        <Card>
          <CardContent className="p-4 space-y-6">
            <div className="flex items-center justify-between gap-2">
              <h2 className="text-xl font-bold">K / L / C ç²¾ç»†æ§åˆ¶ï¼ˆè¿›é˜¶æ¨¡å¼ï¼‰</h2>
              <div className="flex gap-2 flex-wrap">
                <Button variant="outline" onClick={()=>{ resetAdvanced(); showMsg("å·²é‡ç½® K/L/C","success"); }}>é‡ç½® K/L/C</Button>
                <Button onClick={copyApiParams}>å¤åˆ¶ API å‚æ•°</Button>
                <Button variant="secondary" onClick={applyMacroHiKHiLLoC}>ä¸€é”®ï¼šåˆ›ç”Ÿâ†‘ ç»“æ„â†‘ çº¦æŸâ†“</Button>
                <Button variant="outline" onClick={microScan}>Â±0.05 å¾®æ‰«æ</Button>
                <Button variant="outline" onClick={applyGate}>è¿›å…¥ Gateï¼ˆCâ‰ˆ0.6ï¼‰</Button>
                <Button variant="outline" onClick={runSelfTests}>è¿è¡Œè‡ªæµ‹</Button>
              </div>
            </div>

            <div className="grid md:grid-cols-3 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700">K Â· åˆ›ç”Ÿï¼ˆ{klc.K.toFixed(2)}ï¼‰</label>
                <Slider value={[klc.K]} onValueChange={(v)=>setPart("K", +v[0])} min={0} max={1} step={0.01} />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">L Â· ç»“æ„ï¼ˆ{klc.L.toFixed(2)}ï¼‰</label>
                <Slider value={[klc.L]} onValueChange={(v)=>setPart("L", +v[0])} min={0} max={1} step={0.01} />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">C Â· çº¦æŸï¼ˆ{klc.C.toFixed(2)}ï¼‰</label>
                <Slider value={[klc.C]} onValueChange={(v)=>setPart("C", +v[0])} min={0} max={1} step={0.01} />
              </div>
            </div>
            <p className="text-xs text-gray-500">K+L+C=1ï¼›Profile æ”¹å˜æ˜ å°„èŒƒå›´ã€‚å»ºè®®ï¼šå†²åˆº Râ‰ˆ0.35ï¼Œæ”¶å£ Râ‰¥0.60ã€‚</p>

            {/* API å‚æ•°é¢„è§ˆ */}
            <div className="p-4 rounded-md border">
              <h3 className="text-sm font-semibold mb-2">API å‚æ•°å»ºè®®ï¼ˆ{PROFILES[profile].label}ï¼‰</h3>
              <ul className="text-sm space-y-1">
                <li>temperatureï¼š<b>{mapping.temperature}</b></li>
                <li>top_pï¼š<b>{mapping.top_p}</b></li>
                <li>max_tokensï¼š<b>{mapping.max_tokens}</b></li>
              </ul>
            </div>

            {/* æŒ‡æ ‡é¢æ¿ */}
            <div className="p-4 rounded-md border">
              <h3 className="text-sm font-semibold mb-2">D/S/R æŒ‡æ ‡ï¼ˆåŸºäºå½“å‰æ–‡æœ¬ï¼‰</h3>
              <div className="grid md:grid-cols-3 gap-3 text-sm">
                {([{k:"D",label:"å¤šæ ·æ€§",tar:0.75},{k:"S",label:"ç»“æ„åº¦",tar:0.70},{k:"R",label:"å¯è¯åº¦",tar:0.35}]).map(item=> (
                  <div key={item.k}>
                    <div className="flex justify-between"><span>{item.label}</span><span>{metrics[item.k]} / ç›®æ ‡ {item.tar}</span></div>
                    <div className="h-2 bg-gray-200 rounded"><div className="h-2 rounded" style={{width:`${Math.min(100,metrics[item.k]*100)}%`, backgroundColor: metrics[item.k]>=item.tar?"#16a34a":"#f59e0b"}}/></div>
                  </div>
                ))}
              </div>
              {/* v1 å»ºè®® */}
              {scan && (
                <div className="mt-3 text-sm">
                  <div className="font-medium">å»ºè®®æ‹¨æ†ï¼ˆv1ï¼‰ï¼š{scan.note}</div>
                  <div className="text-gray-600">Kâ†’{scan.suggest.K.toFixed(2)}ï¼ŒLâ†’{scan.suggest.L.toFixed(2)}ï¼ŒCâ†’{scan.suggest.C.toFixed(2)}</div>
                  <div className="mt-2 flex gap-2 flex-wrap"><Button size="sm" onClick={applyScanSuggestion}>åº”ç”¨ v1 å»ºè®®</Button><Button size="sm" variant="outline" onClick={()=>setScan(null)}>æ¸…é™¤ v1</Button></div>
                </div>
              )}
              {/* v2 å»ºè®® */}
              {scan2 && (
                <div className="mt-4 text-sm">
                  <div className="font-medium">å»ºè®®æ‹¨æ†ï¼ˆv2ï¼Œäº¤äº’+ä¿¡èµ–åŸŸï¼‰</div>
                  <div className="text-gray-600">Kâ†’{scan2.suggest.K.toFixed(2)}ï¼ŒLâ†’{scan2.suggest.L.toFixed(2)}ï¼ŒCâ†’{scan2.suggest.C.toFixed(2)}ï¼ˆåŠå¾„ {scan2.radius}ï¼‰</div>
                  <div className="mt-1 text-xs text-gray-600">äº¤äº’å¼ºåº¦ï¼ˆ0..1ï¼Œè¶Šé«˜è€¦åˆè¶Šå¼ºï¼‰ï¼š
                    <span className="ml-2">KÃ—L {scan2.coupling["KÃ—L"]}</span>
                    <span className="ml-2">LÃ—C {scan2.coupling["LÃ—C"]}</span>
                    <span className="ml-2">CÃ—K {scan2.coupling["CÃ—K"]}</span>
                  </div>
                  <div className="mt-2 flex gap-2 flex-wrap"><Button size="sm" onClick={applyScan2Suggestion}>åº”ç”¨ v2 å»ºè®®</Button><Button size="sm" variant="outline" onClick={()=>setScan2(null)}>æ¸…é™¤ v2</Button></div>
                </div>
              )}
              <div className="mt-3 flex gap-2 flex-wrap">
                <Button variant="outline" onClick={microScan}>Â±0.05 å¾®æ‰«æï¼ˆv1ï¼‰</Button>
                <Button variant="outline" onClick={()=>microScan2(0.05, 0.12)}>å¾®æ‰«æ 2.0ï¼ˆäº¤äº’+ä¿¡èµ–åŸŸï¼‰</Button>
              </div>
            </div>

            {/* ğŸ§­ é«˜çº§æ§åˆ¶ï¼ˆæ­£äº¤ / è‡ªç„¶æ¢¯åº¦ / Doubt Suite / MBGï¼‰ */}
            <Card>
              <CardContent className="p-4 space-y-4">
                <h3 className="text-xl font-bold">ğŸ§­ é«˜çº§æ§åˆ¶</h3>
                <div className="grid md:grid-cols-2 gap-4">
                  {/* æ­£äº¤æ‹¨æ† */}
                  <div className="p-3 rounded-md border">
                    <div className="flex items-center justify-between">
                      <div className="font-semibold">æ­£äº¤æ‹¨æ†ï¼ˆSVD on Jacobianï¼‰</div>
                      <Button size="sm" variant="outline" onClick={()=>computeOrthogonalAxes()}>è®¡ç®—è½´</Button>
                    </div>
                    {svd ? (
                      <div className="mt-2 text-sm space-y-2">
                        <div>Ïƒ â‰ˆ [{svd.sigma.map(s=>s.toFixed(2)).join(", ")}]</div>
                        <div className="flex gap-2 flex-wrap">
                          <Button size="sm" onClick={()=>stepAlongAxis(0,0.08)}>æ²¿ Axis-1</Button>
                          <Button size="sm" variant="outline" onClick={()=>stepAlongAxis(1,0.06)}>æ²¿ Axis-2</Button>
                          <Button size="sm" variant="outline" onClick={()=>stepAlongAxis(2,0.04)}>æ²¿ Axis-3</Button>
                        </div>
                      </div>
                    ) : <div className="mt-2 text-xs text-gray-600">ç‚¹å‡»â€œè®¡ç®—è½´â€ä»¥è·å– Axis-1/2/3 ä¸å¥‡å¼‚å€¼ã€‚</div>}
                  </div>

                  {/* è‡ªç„¶æ¢¯åº¦ */}
                  <div className="p-3 rounded-md border">
                    <div className="font-semibold">è‡ªç„¶æ¢¯åº¦ï¼ˆsoftmax çº¦æŸï¼‰</div>
                    <div className="mt-2 grid grid-cols-2 gap-2 text-sm">
                      <label className="flex items-center gap-2">Ræƒé‡
                        <input type="number" step="0.05" min="0" max="1" className="w-20 border rounded p-1" value={natGrad.alphaR}
                          onChange={e=>setNatGrad({...natGrad, alphaR:+e.target.value})}/>
                      </label>
                      <label className="flex items-center gap-2">Sæƒé‡
                        <input type="number" step="0.05" min="0" max="1" className="w-20 border rounded p-1" value={natGrad.betaS}
                          onChange={e=>setNatGrad({...natGrad, betaS:+e.target.value})}/>
                      </label>
                      <label className="flex items-center gap-2">Dæƒé‡
                        <input type="number" step="0.05" min="0" max="1" className="w-20 border rounded p-1" value={natGrad.gammaD}
                          onChange={e=>setNatGrad({...natGrad, gammaD:+e.target.value})}/>
                      </label>
                      <label className="flex items-center gap-2">æ­¥é•¿
                        <input type="number" step="0.05" min="0.05" max="1" className="w-20 border rounded p-1" value={natGrad.lr}
                          onChange={e=>setNatGrad({...natGrad, lr:+e.target.value})}/>
                      </label>
                    </div>
                    <div className="mt-2"><Button size="sm" onClick={()=>applyNaturalGradStep()}>åº”ç”¨è‡ªç„¶æ¢¯åº¦æ­¥è¿›</Button></div>
                  </div>
                </div>

                {/* Doubt Suite & Gate */}
                <div className="p-3 rounded-md border">
                  <div className="flex items-center justify-between">
                    <div className="font-semibold">Descartes Doubt Suite & Robust Gate</div>
                    <div className="flex gap-2">
                      <Button size="sm" variant="outline" onClick={runDoubtSuite}>è¿è¡Œ Doubt Suite</Button>
                      <Button size="sm" onClick={evalRobustGate}>Gate åˆ¤å®š</Button>
                    </div>
                  </div>
                  {doubt ? (
                    <div className="mt-2 text-sm">
                      <div>æœ€åä¸€æ¡£ä¸‹ç•Œï¼šR <b>{doubt.lower.R.toFixed(2)}</b>ï¼ŒCD <b>{doubt.lower.CD.toFixed(2)}</b>ï¼ŒD <b>{doubt.lower.D.toFixed(2)}</b>ï¼ŒS <b>{doubt.lower.S.toFixed(2)}</b></div>
                      <div className="text-xs text-gray-600 mt-1">Gate æ¡ä»¶ï¼šRâ‰¥0.60 ä¸” CDâ‰¥0.65ï¼›è‹¥å¯ç”¨ MBGï¼Œåˆ™è¿˜éœ€ MBGâ‰¤0.25ã€‚</div>
                    </div>
                  ) : <div className="mt-2 text-xs text-gray-600">ç‚¹å‡»è¿è¡Œä»¥è®¡ç®—ä¸‰ç§å¯¹æŠ—æƒ…å¢ƒä¸‹çš„æŒ‡æ ‡ä¸‹ç•Œã€‚</div>}
                </div>

                {/* æ„å›¾å¯¹é½ï¼ˆMBGï¼‰ */}
                <div className="p-3 rounded-md border">
                  <div className="font-semibold">ğŸ§  æ„å›¾-æˆæ–‡å¯¹é½ï¼ˆMBGï¼‰</div>
                  <p className="text-xs text-gray-600 mt-1">è¾“å…¥ä½ çš„â€œä¸€å¥è¯æ„å›¾/ç»“è®ºâ€ï¼Œå¯¹æ¯”å½“å‰æ–‡æœ¬ï¼Œè®¡ç®— MBG=1-cosã€‚å»ºè®® Gate å‰ MBGâ‰¤0.25ã€‚</p>
                  <textarea className="w-full min-h-[60px] p-2 border rounded-md mt-2 text-sm" placeholder="ä¾‹å¦‚ï¼šé¢å‘ä¸­å°ä¼ä¸šï¼Œç»™å‡ºä¸€é¡µå¯æ‰§è¡Œå¢é•¿ç­–ç•¥ï¼Œé‡ç‚¹åœ¨ä½æˆæœ¬å®éªŒä¸è¡¡é‡" value={intentText} onChange={(e)=>setIntentText(e.target.value)} />
                  <div className="mt-2 flex items-center gap-3">
                    <Button size="sm" variant="outline" onClick={computeMBG}>è®¡ç®— MBG</Button>
                    <span className="text-sm">{mbg==null? "æœªè®¡ç®—" : `MBG=${mbg}`}</span>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* ğŸ§ª ç¦»çº¿æ¨¡æ‹Ÿï¼ˆæ— éœ€ APIï¼‰ */}
            <Card>
              <CardContent className="p-4 space-y-4">
                <h3 className="text-xl font-bold">ğŸ§ª ç¦»çº¿æ¨¡æ‹Ÿè¾“å‡ºï¼ˆæ— éœ€ APIï¼‰</h3>
                <p className="text-sm text-gray-600">å¡«ä¸»é¢˜â†’ç”Ÿæˆæ–‡æœ¬â†’è§‚å¯Ÿä¸Šæ–¹ D/S/R æ›²çº¿éš K/L/C çš„å˜åŒ–ã€‚</p>
                <textarea className="w-full min-h-[90px] p-2 border rounded-md resize-y focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="è¾“å…¥ä¸€ä¸ªä¸»é¢˜æˆ–æç¤ºè¯â€¦" value={simPrompt} onChange={(e)=>setSimPrompt(e.target.value)} />
                <div className="flex gap-2 flex-wrap">
                  <Button onClick={runOfflineSim}>ç”Ÿæˆæ¨¡æ‹Ÿæ–‡æœ¬</Button>
                  <Button variant="outline" onClick={()=>{ setSimText(""); }}>æ¸…ç©ºç»“æœ</Button>
                </div>
                {simText && (<div className="mt-3 p-4 bg-gray-50 border rounded-md text-sm whitespace-pre-wrap max-h-60 overflow-y-auto">{simText}</div>)}
              </CardContent>
            </Card>

            {/* âœ¨ API ç”Ÿæˆï¼ˆå¯é€‰ï¼Œå¸¦å¼€å…³ï¼‰ */}
            <Card>
              <CardContent className="p-4 space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-xl font-bold">âœ¨ API ç”Ÿæˆï¼ˆå¯é€‰ï¼‰</h3>
                  <label className="flex items-center gap-2 text-sm select-none">
                    <input type="checkbox" checked={apiEnabled} onChange={(e)=>setApiEnabled(e.target.checked)} />
                    <span>{apiEnabled?"å·²å¼€å¯":"å·²å…³é—­"}</span>
                  </label>
                </div>
                <p className="text-xs text-gray-500">å…³é—­æ—¶ä¸è°ƒç”¨å¤–éƒ¨æ¥å£ï¼Œä¿ç•™æœ¬åœ°ç¦»çº¿æ¨¡æ‹Ÿå³å¯ã€‚</p>
                <input type="password" className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="åœ¨æ­¤è¾“å…¥ Gemini API Keyï¼ˆå¯ç•™ç©ºï¼‰" value={apiKey} onChange={(e)=>setApiKey(e.target.value)} disabled={!apiEnabled} />
                <div className="flex gap-2 flex-wrap">
                  <Button onClick={generateText} disabled={!apiEnabled || !apiKey || isLoading}>{isLoading?"ç”Ÿæˆä¸­...":"è°ƒç”¨ API ç”Ÿæˆ"}</Button>
                </div>
                {!apiEnabled && <div className="text-xs text-gray-600">æç¤ºï¼šå½“å‰ API è°ƒç”¨å·²å…³é—­ã€‚å¦‚éœ€å¤–éƒ¨æ¨¡å‹ï¼Œè¯·ä¸Šæ–¹æ‰“å¼€å¼€å…³ã€‚</div>}
                {error && <div className="p-2 text-sm text-red-700 bg-red-50 rounded-md border border-red-200">{error}</div>}
                {response && (<div className="mt-3 p-4 bg-gray-50 border rounded-md text-sm whitespace-pre-wrap max-h-60 overflow-y-auto">{response}</div>)}
              </CardContent>
            </Card>

            {/* ğŸ“Š é»‘ç®±å¯è§†åŒ–é¢æ¿ */}
            <Card>
              <CardContent className="p-4 space-y-5">
                <div className="flex items-center justify-between gap-2">
                  <h3 className="text-xl font-bold">ğŸ“Š é»‘ç®±å¯è§†åŒ–</h3>
                  <div className="flex gap-2 items-center text-sm">
                    <span>çƒ­åŠ›å›¾æŒ‡æ ‡ï¼š</span>
                    {["D","S","R"].map(k=> (
                      <Button key={k} size="sm" variant={heatMetric===k?"default":"outline"} onClick={()=>setHeatMetric(k)}>{k}</Button>
                    ))}
                    <Button size="sm" onClick={runVisuals} disabled={vizRunning}>{vizRunning?"è®¡ç®—ä¸­â€¦":"è¿è¡Œå¯è§†åŒ–"}</Button>
                  </div>
                </div>

                {/* 1) å¤šæ¬¡ç”Ÿæˆç¼å¸¦ */}
                <div className="p-3 rounded-md border">
                  <div className="text-sm font-semibold mb-2">â‘  å¤šæ¬¡ç”Ÿæˆç¨³å®šåº¦ï¼ˆp10 â€” p50 â€” p90ï¼‰</div>
                  {ribbonStats ? (
                    <div className="grid md:grid-cols-3 gap-3 text-sm">
                      {Object.entries(ribbonStats).map(([k,v])=> (
                        <div key={k}>
                          <div className="flex justify-between"><span>{k}</span><span>å‡å€¼ {v.mean}</span></div>
                          <div className="h-3 bg-gray-200 rounded relative">
                            <div className="absolute h-3 rounded" style={{left:`${v.p10*100}%`, width:`${Math.max(1,(v.p90-v.p10)*100)}%`, background: "linear-gradient(90deg, #f59e0b, #10b981)"}} />
                            <div className="absolute -top-4 text-xs" style={{left:`calc(${v.p50*100}% - 6px)`}}>â–²</div>
                          </div>
                          <div className="flex justify-between text-[11px] text-gray-600 mt-1"><span>p10 {v.p10}</span><span>p50 {v.p50}</span><span>p90 {v.p90}</span></div>
                        </div>
                      ))}
                    </div>
                  ) : <div className="text-xs text-gray-500">ç‚¹å‡»ä¸Šæ–¹â€œè¿è¡Œå¯è§†åŒ–â€è®¡ç®—ã€‚</div>}
                </div>

                {/* 2) è¯/å¥é‡è¦åº¦çƒ­å›¾ï¼ˆé®è”½æ³•ï¼‰ */}
                <div className="p-3 rounded-md border">
                  <div className="text-sm font-semibold mb-2">â‘¡ è¯çº§é‡è¦åº¦ï¼ˆé®è”½æ³•ï¼‰</div>
                  {importance ? (
                    <div className="text-sm leading-7 flex flex-wrap">
                      {importance.map((t,i)=> (
                        <span key={i} style={{ backgroundColor: colorScale01(Math.min(1, t.score*2)), borderRadius: 3, padding: t.token.trim()?"0 2px":"0" }}>
                          {t.token}
                        </span>
                      ))}
                    </div>
                  ) : <div className="text-xs text-gray-500">åŸºäºå½“å‰æ–‡æœ¬è‡ªåŠ¨è®¡ç®—ï¼šé¢œè‰²è¶Šç»¿ï¼Œè¶Šå½±å“ D/S/Rï¼›è¶Šçº¢å½±å“è¶Šå°ã€‚</div>}
                </div>

                {/* 3) (KÃ—C) çƒ­åŠ›å›¾ï¼ˆå›ºå®š Lï¼‰ */}
                <div className="p-3 rounded-md border">
                  <div className="text-sm font-semibold mb-2">â‘¢ (KÃ—C) çƒ­åŠ›å›¾ï¼ˆå›ºå®š L={klc.L.toFixed(2)}ï¼‰</div>
                  {heatData ? (
                    <div className="space-y-2">
                      <div className="grid" style={{gridTemplateColumns: `repeat(${heatData[heatMetric][0].length}, minmax(0,1fr))`, gap: 2}}>
                        {heatData[heatMetric].flatMap((row, i)=> row.map((v,j)=> (
                          <div key={`${i}-${j}`} title={`K=${heatData.ks[i].toFixed(2)} C=${heatData.cs[j].toFixed(2)} ${heatMetric}=${v.toFixed(2)}`} style={{backgroundColor: colorScale01(v), height: 16, borderRadius: 2}} />
                        )))}
                      </div>
                      <div className="text-[11px] text-gray-600">æ·±ç»¿=è¯¥æŒ‡æ ‡é«˜ã€‚æç¤ºï¼šç‚¹å‡»â€œå¾®æ‰«æâ€åï¼Œä¼˜å…ˆåœ¨çƒ­åŠ›å›¾çš„â€œç”œåŒºâ€é™„è¿‘å¾®è°ƒæ—‹é’®ã€‚</div>
                    </div>
                  ) : <div className="text-xs text-gray-500">ç‚¹å‡»ä¸Šæ–¹â€œè¿è¡Œå¯è§†åŒ–â€ç”Ÿæˆ 7Ã—7 ç½‘æ ¼ï¼ˆK ä¸ C å˜åŒ–ï¼ŒL å›ºå®šï¼‰ã€‚</div>}
                </div>

                {/* 4) äº‹ä»¶æ—¶é—´çº¿ */}
                <div className="p-3 rounded-md border">
                  <div className="text-sm font-semibold mb-2">â‘£ äº‹ä»¶æ—¶é—´çº¿</div>
                  {history.length? (
                    <ul className="text-xs space-y-1 max-h-40 overflow-auto">
                      {[...history].slice(-12).reverse().map((h,i)=> (
                        <li key={i} className="flex items-center gap-2">
                          <span className="inline-block w-2 h-2 rounded-full" style={{backgroundColor: h.source==="api"?"#3b82f6":"#6b7280"}}/>
                          <span>{new Date(h.t).toLocaleTimeString()}</span>
                          <span>u=({h.u.K.toFixed(2)}, {h.u.L.toFixed(2)}, {h.u.C.toFixed(2)})</span>
                          <span>m=({h.m.D.toFixed(2)}, {h.m.S.toFixed(2)}, {h.m.R.toFixed(2)})</span>
                          {h.note && <span className="text-gray-600">â€” {h.note}</span>}
                        </li>
                      ))}
                    </ul>
                  ) : <div className="text-xs text-gray-500">æš‚æ— å†å²ã€‚è¿è¡Œæ¨¡æ‹Ÿ/å¯è§†åŒ–åä¼šè®°å½•å‚æ•°ä¸æŒ‡æ ‡å˜åŒ–ã€‚</div>}
                </div>
              </CardContent>
            </Card>

          </CardContent>
        </Card>
      )}
    </div>
  );
}
